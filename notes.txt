Todo
====

Note byte code is from python 3.3!

FIXME need to be able to tell classes an instances apart!

Put C modules in sub directory
Make an all submodule so can insert all of them easily with 

  import _ "github.com/ncw/gpython/stdlib/all"

Factor main code into submodule so gpython is minimal.

Make a gpython-minimal with no built in stdlib

Bytecode compile the standard library and embed into go files - can then make a gpython with no external files.

Testing
=======

  python3 -m dis hello.py
  python3 -mcompileall hello.py 
  mv __pycache__/hello.cpython-33.pyc hello.pyc
  python3 -c 'import hello; import dis; dis.dis(hello.fn)'

  go build ./... && go build
  ./gpython hello.pyc

Polymorphism
============

  Want to try to retain I__XXX__ and M__XXX__ for speed

  so first try

  ok, I := obj.(.I__XXX__)
  if ok {
      res = I.M__XXX__(obj)
  }
  
  However want to be able to look up "__XXX__" in dict

  ok, res := obj.Type().Call0("__XXX__")
  ok, res := obj.Type().Call1("__XXX__", a)
  ok, res := obj.Type().Call2("__XXX__", b)
  ok is method found
  res is valid if found (or maybe NotImplemented)
  
  Call() looks up name in methods and if found calls it either C wise or py-wise

  Calling C-wise is easy enough, but how to call py-wise?

  Assuming we are being called from the VM we would like to use the
  same VM to execute it? Or could make a new one which seems a little
  expensive and what is going to happen to exceptions and unwinding
  the stack?

  Looks like python makes a new vm with PyEval_EvalCode so will need
  to make sure we store the unwinding stack frame in the exception
  (which is what python does I think)

all together
  
  var ok bool
  var res Object

  if ok, I := obj.(.I__XXX__); ok {
      res = I.M__XXX__(b)
  } else ok, res = obj.Type().Call1("__XXX__", b); !ok {
      res = NotImplemented
  }

ObjectType in *Type is probably redundant
- except that Base can be nil

Todo
====

  * Closures
  * With statements
  * Import

Difference between gpython and cpython
======================================

Uses native types for some of the objects, eg String, Int, Tuple, StringDict

Does not support threading, so no thread state or thread local variables

Attributes of built in types
============================

Use introspection to find methods of built in types and to find attributes

When the built in type is created with TypeNew fill up the type Dict
with the methods and data descriptors (which implement __get__
and __set__ as appropriate)

Introspect attributes by looking for `py:"args"` in the structure
type.  If it is writable it has a ",w" flag `py:"args,w"` - we'll use
the type of the structure member to convert the incoming arg, so if it
is a Tuple() we'll call MakeTuple() on it, etc.  The attribute can
also have help on it, eg `py:"__cause__,r,exception cause"`

Introspect methods by looking at all public methods

Transform the names, so that initial "M__" becomes "__" then lowercase
the method. Only if the method matches one of the defined function types will it be exported.
FIXME meta data for help would be nice?  How attache metadata to go function?

Introspection idea
==================

	var method string
	if strings.HasPrefix(key, "_") {
		method = "M" + key
	} else {
		method = strings.Title(key)
	}
	fmt.Printf("*** looking for method %q (key %q)\n", method, key)
	r := reflect.TypeOf(self)
	if m, ok := r.MethodByName(method); ok {
		fmt.Printf("*** m = %#v\n", m.Func)
		fmt.Printf("*** type = %#v\n", m.Func.Type())

		var fptr func(Object) Object

		// fptr is a pointer to a function.
		// Obtain the function value itself (likely nil) as a reflect.Value
		// so that we can query its type and then set the value.
		fn := reflect.ValueOf(fptr).Elem()

		// Make a function of the right type.
		v := reflect.MakeFunc(fn.Type(), m.Func)

		// Assign it to the value fn represents.
		fn.Set(v)

		fmt.Printf("fptr = %v\n", fptr)

	} else {
		fmt.Printf("*** method not found\n")
	}

