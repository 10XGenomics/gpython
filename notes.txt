Todo
====

Note byte code is from python 3.3!

FIXME need to be able to tell classes an instances apart!

Put C modules in sub directory
Make an all submodule so can insert all of them easily with 

  import _ "github.com/ncw/gpython/stdlib/all"

Factor main code into submodule so gpython is minimal.

Make a gpython-minimal with no built in stdlib

Bytecode compile the standard library and embed into go files - can then make a gpython with no external files.

Testing
=======

  python3 -m dis hello.py
  python3 -mcompileall hello.py 
  mv __pycache__/hello.cpython-33.pyc hello.pyc
  python3 -c 'import hello; import dis; dis.dis(hello.fn)'

  go build ./... && go build
  ./gpython hello.pyc

When converting C code, run it through astyle first as a first pass

astyle --style=java --add-brackets < x.c > x.go

Roadmap
=======
  * FIXME (int("a", base=16): gives int() got multiple values for argument 'base'
  * make pystone.py work
  * make enough of internals work so can run python tests
  * import python tests and write go test runner to run them
  * make lots of them pass

Missing parts
=============
  * repr/str
  * subclassing built in types

Polymorphism
============

  Want to try to retain I__XXX__ and M__XXX__ for speed

  so first try

  ok, I := obj.(.I__XXX__)
  if ok {
      res = I.M__XXX__(obj)
  }
  
  However want to be able to look up "__XXX__" in dict

  ok, res := obj.Type().Call0("__XXX__")
  ok, res := obj.Type().Call1("__XXX__", a)
  ok, res := obj.Type().Call2("__XXX__", a, b)
  ok is method found
  res is valid if found (or maybe NotImplemented)
  
  Call() looks up name in methods and if found calls it either C wise or py-wise

  Calling C-wise is easy enough, but how to call py-wise?

all together
  
  var ok bool
  var res Object

  if ok, I := obj.(.I__XXX__); ok {
      res = I.M__XXX__(b)
  } else ok, res = obj.Type().Call1("__XXX__", b); !ok {
      res = NotImplemented
  }

ObjectType in *Type is probably redundant
- except that Base can be nil

Todo
====

  * With statements
  * Import
  * Dict
  * Set
  * Tracebacks - need to update the traceback object when unwinding the stack - could include go traceback too

Difference between gpython and cpython
======================================

Uses native types for some of the objects, eg String, Int, Tuple, StringDict

The immutable types String, Int are passed by value. Tuple is an
[]Object which is a reference type as is StringDict which is a
map[string]Object. Note that Tuples can't be appended to.

Note that strings are kept as Go native utf-8 encoded strings.  This
makes for a small amount of awkwardness when indexing etc, but makes
life much easier interfacing with Go.

List is a struct with a []Object in it so append can mutate the list.

All other types are pointers to structures.

Does not support threading, so no thread state or thread local
variables as the intention is to support go routines and channels via
the threading module.

Attributes of built in types
============================

Use introspection to find methods of built in types and to find attributes

When the built in type is created with TypeNew fill up the type Dict
with the methods and data descriptors (which implement __get__
and __set__ as appropriate)

Introspect attributes by looking for `py:"args"` in the structure
type.  If it is writable it has a ",w" flag `py:"args,w"` - we'll use
the type of the structure member to convert the incoming arg, so if it
is a Tuple() we'll call MakeTuple() on it, etc.  The attribute can
also have help on it, eg `py:"__cause__,r,exception cause"`

Introspect methods by looking at all public methods

Transform the names, so that initial "M__" becomes "__" then lowercase
the method. Only if the method matches one of the defined function types will it be exported.
FIXME meta data for help would be nice?  How attache metadata to go function?

Introspection idea
==================

	var method string
	if strings.HasPrefix(key, "_") {
		method = "M" + key
	} else {
		method = strings.Title(key)
	}
	fmt.Printf("*** looking for method %q (key %q)\n", method, key)
	r := reflect.TypeOf(self)
	if m, ok := r.MethodByName(method); ok {
		fmt.Printf("*** m = %#v\n", m.Func)
		fmt.Printf("*** type = %#v\n", m.Func.Type())

		var fptr func(Object) Object

		// fptr is a pointer to a function.
		// Obtain the function value itself (likely nil) as a reflect.Value
		// so that we can query its type and then set the value.
		fn := reflect.ValueOf(fptr).Elem()

		// Make a function of the right type.
		v := reflect.MakeFunc(fn.Type(), m.Func)

		// Assign it to the value fn represents.
		fn.Set(v)

		fmt.Printf("fptr = %v\n", fptr)

	} else {
		fmt.Printf("*** method not found\n")
	}

