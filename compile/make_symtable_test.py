#!/usr/bin/env python3.4
"""
Write symtable_data_test.go
"""

import sys
import ast
import subprocess
import dis
from symtable import symtable

# FIXME test errors too

inp = [
    ('''1''', "eval"),
    #('''a*b*c''', "eval"),
    #('''def fn(): pass''', "exec"),
    #('''def fn(a,b):\n e=1\n return a*b*c*d*e''', "exec"),
    #('''def fn(a,b):\n def nested(c,d):\n  return a*b*c*d*e''', "exec"),
    # ('''def fn(a,b,c): pass''', "exec"),
    # ('''def fn(a,b=1,c=2): pass''', "exec"),
    # ('''def fn(a,*arg,b=1,c=2): pass''', "exec"),
    # ('''def fn(a,*arg,b=1,c=2,**kwargs): pass''', "exec"),
    # ('''def fn(a:"a",*arg:"arg",b:"b"=1,c:"c"=2,**kwargs:"kw") -> "ret": pass''', "exec"),
    # ('''def fn(): a+b''', "exec"),
]

def dump_bool(b):
    return ("true" if b else "false")

def dump_strings(ss):
    return "[]string{"+",".join([ '"%s"' % s for s in ss ])+"}"

# Scope numbers to names (from symtable.h)
SCOPES = {
    1: "scopeLocal",
    2: "scopeGlobalExplicit",
    3: "scopeGlobalImplicit",
    4: "scopeFree",
    5: "scopeCell",
}

#def-use flags to names (from symtable.h)
DEF_FLAGS = (
    ("defGlobal", 1),      # global stmt
    ("defLocal", 2),       # assignment in code block
    ("defParam", 2<<1),    # formal parameter
    ("defNonlocal", 2<<2), # nonlocal stmt
    ("defUse", 2<<3),      # name is used
    ("defFree", 2<<4),     # name used but not defined in nested block
    ("defFreeClass", 2<<5),# free variable from class's method
    ("defImport", 2<<6),   # assignment occurred via import
)

BLOCK_TYPES = {
    "function": "FunctionBlock",
    "class": "ClassBlock",
    "module": "ModuleBlock",
}

def dump_symtable(st):
    """Dump the symtable"""
    out = "&SymTable{\n"
    out += 'Type:%s,\n' % BLOCK_TYPES[st.get_type()] # Return the type of the symbol table. Possible values are 'class', 'module', and 'function'.
    out += 'Name:"%s",\n' % st.get_name() # Return the table’s name. This is the name of the class if the table is for a class, the name of the function if the table is for a function, or 'top' if the table is global (get_type() returns 'module').

    out += 'Lineno:%s,\n' % st.get_lineno() # Return the number of the first line in the block this table represents.
    out += 'Optimized:%s,\n' % dump_bool(st.is_optimized()) # Return True if the locals in this table can be optimized.
    out += 'Nested:%s,\n' % dump_bool(st.is_nested()) # Return True if the block is a nested class or function.
    out += 'Exec:%s,\n' % dump_bool(st.has_exec()) # Return True if the block uses exec.
    out += 'ImportStar:%s,\n' % dump_bool(st.has_import_star()) # Return True if the block uses a starred from-import.
    out += 'Symbols: Symbols{\n'
    for name in st.get_identifiers():
        value = st.lookup(name)
        out += '"%s":%s,\n' % (name, dump_symbol(value))
    out += '},\n'
    # out += 'children:"%s",\n' % st.get_children() # Return a list of the nested symbol tables.
    out += "}"
    return out

def dump_symbol(s):
    """Dump a symbol"""
    #class symtable.Symbol
    # An entry in a SymbolTable corresponding to an identifier in the source. The constructor is not public.
    out = "Symbol{\n"
    out += 'Name:"%s",\n' % s.get_name() # Return the symbol’s name.
    flags = []
    flag_bits = s._Symbol__flags
    for name, mask in DEF_FLAGS:
        if (flag_bits & mask) != 0:
            flags.append(name)
    if not flags:
        flags = ["0"]
    out += 'Flags:%s,\n' % "|".join(flags)

    scope = SCOPES.get(s._Symbol__scope, "scopeUnknown")
    out += 'Scope:%s,\n' % scope

    # Return a namespace bound to this name.
    ns = s.get_namespaces()
    if len(ns) == 0:
        pass
    elif len(ns) == 1:
        out += 'Namespace:%s,\n' % dump_symtable(ns[0])
    else:
        raise AssertionError("More than one namespace")
    out += "}"
    return out

def escape(x):
    """Encode strings with backslashes for python/go"""
    return x.replace('\\', "\\\\").replace('"', r'\"').replace("\n", r'\n').replace("\t", r'\t')

def main():
    """Write symtable_data_test.go"""
    path = "symtable_data_test.go"
    out = ["""// Test data generated by make_symtable_test.py - do not edit

package compile

import (
"github.com/ncw/gpython/py"
)

var symtableTestData = []struct {
in   string
mode string // exec, eval or single
out  *SymTable
exceptionType *py.Type
errString string
}{"""]
    for x in inp:
        source, mode = x[:2]
        if len(x) > 2:
            exc = x[2]
            try:
                table = symtable(source, "<string>", mode)
            except exc as e:
                error = e.msg
            else:
                raise ValueError("Expecting exception %s" % exc)
            table = "nil"
            gostring = "nil"
            exc_name = "py.%s" % exc.__name__
        else:
            table = symtable(source, "<string>", mode)
            exc_name = "nil"
            error = ""
        out.append('{"%s", "%s", %s, %s, "%s"},' % (escape(source), mode, dump_symtable(table), exc_name, escape(error)))
    out.append("}\n")
    print("Writing %s" % path)
    with open(path, "w") as f:
        f.write("\n".join(out))
        f.write("\n")
    subprocess.check_call(["gofmt", "-w", path])

if __name__ == "__main__":
    main()
